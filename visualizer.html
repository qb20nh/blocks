<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Color Visualizer (OKLAB)</title>
    <link rel="preconnect" href="https://unpkg.com">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: auto;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            cursor: pointer;
            margin-top: 5px;
        }

        button:hover {
            background: #555;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <link rel="modulepreload" href="https://unpkg.com/three@0.160.0/build/three.module.js" crossorigin="anonymous">
    <link rel="modulepreload" href="https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        crossorigin="anonymous">
</head>

<body>
    <div id="info">
        <h2>OKLAB Color Space Visualizer</h2>
        <div style="margin-bottom: 10px;">
            <label for="colorCount">Colors (N): </label>
            <input type="number" id="colorCount" min="3" max="64" value="16"
                style="width: 50px; background: #333; color: white; border: 1px solid #555;">
        </div>
        <button id="toggleMode">Switch to sRGB</button>
        <p id="status">Loading data...</p>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- OKLAB Math ---
        // Converted from https://bottosson.github.io/posts/oklab/

        function sRGB_to_linear(c) {
            return (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        }

        function linear_sRGB_to_OKLAB(r, g, b) {
            let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
            let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
            let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

            let l_ = Math.cbrt(l);
            let m_ = Math.cbrt(m);
            let s_ = Math.cbrt(s);

            return {
                L: 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
                a: 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
                b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
            };
        }

        function sRGB_to_OKLAB(r, g, b) {
            return linear_sRGB_to_OKLAB(sRGB_to_linear(r / 255), sRGB_to_linear(g / 255), sRGB_to_linear(b / 255));
        }

        function linear_sRGB_to_sRGB(c) {
            return (c <= 0.0031308) ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        }

        function OKLAB_to_linear_sRGB(L, a, b) {
            let l_ = L + 0.3963377774 * a + 0.2158037573 * b;
            let m_ = L - 0.1055613458 * a - 0.0638541728 * b;
            let s_ = L - 0.0894841775 * a - 1.2914855480 * b;

            let l = l_ * l_ * l_;
            let m = m_ * m_ * m_;
            let s = s_ * s_ * s_;

            return {
                r: +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
                g: -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
                b: -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
            };
        }

        function OKLAB_to_sRGB(L, a, b) {
            let lin = OKLAB_to_linear_sRGB(L, a, b);
            return {
                r: linear_sRGB_to_sRGB(lin.r),
                g: linear_sRGB_to_sRGB(lin.g),
                b: linear_sRGB_to_sRGB(lin.b)
            };
        }

        // --- Shaders ---
        const vertexShaderCommon = `
            uniform float uT;
            attribute vec3 oklabPos;
            attribute vec3 srgbPos;
            attribute vec3 color;
            varying vec3 vColor;
            
            void main() {
                vColor = color;
                vec3 pos = mix(oklabPos, srgbPos, uT);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShaderCommon = `
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // For Lines, we might want opacity
        const fragmentShaderLines = `
            varying vec3 vColor;
            uniform float opacity;
            void main() {
                gl_FragColor = vec4(vColor, opacity);
            }
        `;

        // For Instanced Spheres
        // We use a slightly different vertex shader because we need to add the sphere's local position
        const vertexShaderInstanced = `
            uniform float uT;
            attribute vec3 instanceOklabPos;
            attribute vec3 instanceSrgbPos;
            attribute vec3 instanceColor;
            varying vec3 vColor;

            void main() {
                vColor = instanceColor;
                vec3 offset = mix(instanceOklabPos, instanceSrgbPos, uT);
                vec3 transformed = position + offset;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
        `;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        camera.position.set(0.8, 0.8, 0.8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0.5, 0);

        // Idle Render Logic
        let renderRequested = false;
        function requestRender() {
            if (!renderRequested) {
                renderRequested = true;
                requestAnimationFrame(render);
            }
        }

        controls.addEventListener('change', requestRender);

        // --- Animation State ---
        let targetMode = 0; // 0 = Oklab, 1 = sRGB
        let currentT = 0;
        let animationProgress = 0;

        // Uniforms shared by materials
        const uniforms = {
            uT: { value: 0 }
        };

        // --- Geometry Creation ---

        // Custom Axes
        function createAxes() {
            const axesGroup = new THREE.Group();
            const steps = 64;

            function addGradientAxis(start, end) {
                const positions = []; // Dummy positions, shader uses attributes
                const oklabPos = [];
                const srgbPos = [];
                const colors = [];

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = start.x + (end.x - start.x) * t;
                    const y = start.y + (end.y - start.y) * t;
                    const z = start.z + (end.z - start.z) * t;

                    positions.push(0, 0, 0); // Not used but required for bounding box calc usually

                    // Oklab Position
                    oklabPos.push(x, y, z);

                    // sRGB Position (mapped from Oklab)
                    const rgb = OKLAB_to_sRGB(y, x, z); // L=y, a=x, b=z
                    const r = Math.max(0, Math.min(1, rgb.r));
                    const g = Math.max(0, Math.min(1, rgb.g));
                    const bl = Math.max(0, Math.min(1, rgb.b));

                    // Center sRGB: subtract 0.5 from x and z, then scale by 0.8 to match axes
                    srgbPos.push((r - 0.5) * 0.8, g, (bl - 0.5) * 0.8);

                    colors.push(r, g, bl);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('oklabPos', new THREE.Float32BufferAttribute(oklabPos, 3));
                geometry.setAttribute('srgbPos', new THREE.Float32BufferAttribute(srgbPos, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: vertexShaderCommon,
                    fragmentShader: fragmentShaderCommon,
                    transparent: false,
                    linewidth: 2
                });

                axesGroup.add(new THREE.Line(geometry, material));
            }

            // L axis (Vertical)
            addGradientAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
            // a axis (Horizontal)
            addGradientAxis(new THREE.Vector3(-0.4, 0.5, 0), new THREE.Vector3(0.4, 0.5, 0));
            // b axis (Depth)
            addGradientAxis(new THREE.Vector3(0, 0.5, -0.4), new THREE.Vector3(0, 0.5, 0.4));

            scene.add(axesGroup);
        }
        createAxes();

        // --- Gamut Visualization ---
        function createGamutWireframe() {
            const steps = 20;
            const gridDivisions = 10;

            // Calculate total vertices for grid
            // 6 faces * (gridDivisions - 1) lines * 2 directions * steps segments * 2 vertices
            const gridSegmentCount = 6 * (gridDivisions - 1) * 2;
            const totalGridVertices = gridSegmentCount * steps * 2;

            const gridOklabPos = new Float32Array(totalGridVertices * 3);
            const gridSrgbPos = new Float32Array(totalGridVertices * 3);
            const gridColors = new Float32Array(totalGridVertices * 3);
            const gridDummyPos = new Float32Array(totalGridVertices * 3); // Zeros

            let gridIdx = 0;

            function addGridSegment(p1x, p1y, p1z, p2x, p2y, p2z, fixedDim, fixedVal) {
                const dx = p2x - p1x;
                const dy = p2y - p1y;
                const dz = p2z - p1z;

                for (let i = 0; i < steps; i++) {
                    const t1 = i / steps;
                    const t2 = (i + 1) / steps;

                    // Point 1
                    const c1x = p1x + dx * t1;
                    const c1y = p1y + dy * t1;
                    const c1z = p1z + dz * t1;

                    // Point 2
                    const c2x = p1x + dx * t2;
                    const c2y = p1y + dy * t2;
                    const c2z = p1z + dz * t2;

                    // sRGB positions (Centered and Scaled)
                    gridSrgbPos[gridIdx] = (c1x - 0.5) * 0.8;
                    gridSrgbPos[gridIdx + 1] = c1y;
                    gridSrgbPos[gridIdx + 2] = (c1z - 0.5) * 0.8;

                    gridSrgbPos[gridIdx + 3] = (c2x - 0.5) * 0.8;
                    gridSrgbPos[gridIdx + 4] = c2y;
                    gridSrgbPos[gridIdx + 5] = (c2z - 0.5) * 0.8;

                    // Oklab positions
                    const o1 = sRGB_to_OKLAB(c1x * 255, c1y * 255, c1z * 255);
                    const o2 = sRGB_to_OKLAB(c2x * 255, c2y * 255, c2z * 255);

                    gridOklabPos[gridIdx] = o1.a;
                    gridOklabPos[gridIdx + 1] = o1.L;
                    gridOklabPos[gridIdx + 2] = o1.b;

                    gridOklabPos[gridIdx + 3] = o2.a;
                    gridOklabPos[gridIdx + 4] = o2.L;
                    gridOklabPos[gridIdx + 5] = o2.b;

                    // Color (Constant Grey)
                    gridColors[gridIdx] = 0.33; gridColors[gridIdx + 1] = 0.33; gridColors[gridIdx + 2] = 0.33;
                    gridColors[gridIdx + 3] = 0.33; gridColors[gridIdx + 4] = 0.33; gridColors[gridIdx + 5] = 0.33;

                    gridIdx += 6;
                }
            }

            function drawFaceGrid(fixedDim, fixedVal) {
                for (let i = 1; i < gridDivisions; i++) {
                    const t = i / gridDivisions;

                    // Line 1
                    let s1x = 0, s1y = 0, s1z = 0;
                    let e1x = 0, e1y = 0, e1z = 0;

                    if (fixedDim === 0) { s1x = fixedVal; e1x = fixedVal; }
                    if (fixedDim === 1) { s1y = fixedVal; e1y = fixedVal; }
                    if (fixedDim === 2) { s1z = fixedVal; e1z = fixedVal; }

                    const d1 = (fixedDim + 1) % 3;
                    const d2 = (fixedDim + 2) % 3;

                    // Set start/end for d1=0..1, d2=t
                    if (d1 === 0) { s1x = 0; e1x = 1; }
                    if (d1 === 1) { s1y = 0; e1y = 1; }
                    if (d1 === 2) { s1z = 0; e1z = 1; }

                    if (d2 === 0) { s1x = t; e1x = t; }
                    if (d2 === 1) { s1y = t; e1y = t; }
                    if (d2 === 2) { s1z = t; e1z = t; }

                    addGridSegment(s1x, s1y, s1z, e1x, e1y, e1z);

                    // Line 2
                    let s2x = 0, s2y = 0, s2z = 0;
                    let e2x = 0, e2y = 0, e2z = 0;

                    if (fixedDim === 0) { s2x = fixedVal; e2x = fixedVal; }
                    if (fixedDim === 1) { s2y = fixedVal; e2y = fixedVal; }
                    if (fixedDim === 2) { s2z = fixedVal; e2z = fixedVal; }

                    // Set start/end for d2=0..1, d1=t
                    if (d2 === 0) { s2x = 0; e2x = 1; }
                    if (d2 === 1) { s2y = 0; e2y = 1; }
                    if (d2 === 2) { s2z = 0; e2z = 1; }

                    if (d1 === 0) { s2x = t; e2x = t; }
                    if (d1 === 1) { s2y = t; e2y = t; }
                    if (d1 === 2) { s2z = t; e2z = t; }

                    addGridSegment(s2x, s2y, s2z, e2x, e2y, e2z);
                }
            }

            drawFaceGrid(0, 0); drawFaceGrid(0, 1);
            drawFaceGrid(1, 0); drawFaceGrid(1, 1);
            drawFaceGrid(2, 0); drawFaceGrid(2, 1);

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.BufferAttribute(gridDummyPos, 3));
            gridGeo.setAttribute('oklabPos', new THREE.BufferAttribute(gridOklabPos, 3));
            gridGeo.setAttribute('srgbPos', new THREE.BufferAttribute(gridSrgbPos, 3));
            gridGeo.setAttribute('color', new THREE.BufferAttribute(gridColors, 3));

            const gridMat = new THREE.ShaderMaterial({
                uniforms: { ...uniforms, opacity: { value: 0.1 } },
                vertexShader: vertexShaderCommon,
                fragmentShader: fragmentShaderLines,
                transparent: true,
                depthWrite: false
            });
            const gridLines = new THREE.LineSegments(gridGeo, gridMat);
            scene.add(gridLines);

            // Main Edges
            const edgeCount = 12;
            const totalEdgeVertices = edgeCount * steps * 2;

            const edgeOklabPos = new Float32Array(totalEdgeVertices * 3);
            const edgeSrgbPos = new Float32Array(totalEdgeVertices * 3);
            const edgeColors = new Float32Array(totalEdgeVertices * 3);
            const edgeDummyPos = new Float32Array(totalEdgeVertices * 3);

            let edgeIdx = 0;

            function addColoredEdge(p1x, p1y, p1z, p2x, p2y, p2z) {
                const dx = p2x - p1x;
                const dy = p2y - p1y;
                const dz = p2z - p1z;

                for (let i = 0; i < steps; i++) {
                    const t1 = i / steps;
                    const t2 = (i + 1) / steps;

                    const c1x = p1x + dx * t1;
                    const c1y = p1y + dy * t1;
                    const c1z = p1z + dz * t1;

                    const c2x = p1x + dx * t2;
                    const c2y = p1y + dy * t2;
                    const c2z = p1z + dz * t2;

                    // sRGB
                    edgeSrgbPos[edgeIdx] = (c1x - 0.5) * 0.8;
                    edgeSrgbPos[edgeIdx + 1] = c1y;
                    edgeSrgbPos[edgeIdx + 2] = (c1z - 0.5) * 0.8;

                    edgeSrgbPos[edgeIdx + 3] = (c2x - 0.5) * 0.8;
                    edgeSrgbPos[edgeIdx + 4] = c2y;
                    edgeSrgbPos[edgeIdx + 5] = (c2z - 0.5) * 0.8;

                    // Oklab
                    const o1 = sRGB_to_OKLAB(c1x * 255, c1y * 255, c1z * 255);
                    const o2 = sRGB_to_OKLAB(c2x * 255, c2y * 255, c2z * 255);

                    edgeOklabPos[edgeIdx] = o1.a;
                    edgeOklabPos[edgeIdx + 1] = o1.L;
                    edgeOklabPos[edgeIdx + 2] = o1.b;

                    edgeOklabPos[edgeIdx + 3] = o2.a;
                    edgeOklabPos[edgeIdx + 4] = o2.L;
                    edgeOklabPos[edgeIdx + 5] = o2.b;

                    // Color
                    edgeColors[edgeIdx] = c1x; edgeColors[edgeIdx + 1] = c1y; edgeColors[edgeIdx + 2] = c1z;
                    edgeColors[edgeIdx + 3] = c2x; edgeColors[edgeIdx + 4] = c2y; edgeColors[edgeIdx + 5] = c2z;

                    edgeIdx += 6;
                }
            }

            addColoredEdge(0, 0, 0, 1, 0, 0); addColoredEdge(1, 0, 0, 1, 1, 0); addColoredEdge(1, 1, 0, 0, 1, 0); addColoredEdge(0, 1, 0, 0, 0, 0);
            addColoredEdge(0, 0, 1, 1, 0, 1); addColoredEdge(1, 0, 1, 1, 1, 1); addColoredEdge(1, 1, 1, 0, 1, 1); addColoredEdge(0, 1, 1, 0, 0, 1);
            addColoredEdge(0, 0, 0, 0, 0, 1); addColoredEdge(1, 0, 0, 1, 0, 1); addColoredEdge(1, 1, 0, 1, 1, 1); addColoredEdge(0, 1, 0, 0, 1, 1);

            const edgeGeo = new THREE.BufferGeometry();
            edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgeDummyPos, 3));
            edgeGeo.setAttribute('oklabPos', new THREE.BufferAttribute(edgeOklabPos, 3));
            edgeGeo.setAttribute('srgbPos', new THREE.BufferAttribute(edgeSrgbPos, 3));
            edgeGeo.setAttribute('color', new THREE.BufferAttribute(edgeColors, 3));

            const edgeMat = new THREE.ShaderMaterial({
                uniforms: { ...uniforms, opacity: { value: 0.8 } },
                vertexShader: vertexShaderCommon,
                fragmentShader: fragmentShaderLines,
                transparent: true,
                linewidth: 2
            });
            const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
            scene.add(edgeLines);
        }

        createGamutWireframe();

        // --- Data Loading ---
        const MAX_INSTANCES = 64;
        let instancedMesh;
        let instanceOklabPos, instanceSrgbPos, instanceColor;

        // Initialize InstancedMesh once
        function initInstancedMesh() {
            const geometry = new THREE.SphereGeometry(0.02, 16, 16);
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShaderInstanced,
                fragmentShader: fragmentShaderCommon
            });

            instancedMesh = new THREE.InstancedMesh(geometry, material, MAX_INSTANCES);
            instancedMesh.count = 0; // Start hidden
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.frustumCulled = false; // Critical: Vertex shader moves points outside original bounds

            instanceOklabPos = new Float32Array(MAX_INSTANCES * 3);
            instanceSrgbPos = new Float32Array(MAX_INSTANCES * 3);
            instanceColor = new Float32Array(MAX_INSTANCES * 3);

            const geometryAttr = instancedMesh.geometry;
            geometryAttr.setAttribute('instanceOklabPos', new THREE.InstancedBufferAttribute(instanceOklabPos, 3).setUsage(THREE.DynamicDrawUsage));
            geometryAttr.setAttribute('instanceSrgbPos', new THREE.InstancedBufferAttribute(instanceSrgbPos, 3).setUsage(THREE.DynamicDrawUsage));
            geometryAttr.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColor, 3).setUsage(THREE.DynamicDrawUsage));

            scene.add(instancedMesh);
        }

        initInstancedMesh();

        async function loadData(n) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `Loading results/colors_${n}.txt...`;

            try {
                const response = await fetch(`results/colors_${n}.txt`);
                if (!response.ok) throw new Error(`File not found: ${response.statusText}`);

                const text = await response.text();

                let count = 0;
                let cursor = 0;
                const len = text.length;

                // Reusable dummy for matrix update
                const dummy = new THREE.Object3D();
                dummy.position.set(0, 0, 0);
                dummy.updateMatrix();
                const matrix = dummy.matrix;

                // Split by lines to handle the variable whitespace correctly
                const lines = text.split('\n');

                for (let i = 0; i < lines.length && count < MAX_INSTANCES; i++) {
                    let line = lines[i].trim();
                    if (line.length > 0 && /^\d+/.test(line)) {
                        const parts = line.split(/\s+/);
                        if (parts.length >= 3) {
                            const hexStr = parts[1];
                            const rgbStr = parts[2];

                            const rgbParts = rgbStr.split(',');
                            if (rgbParts.length === 3) {
                                const r = parseInt(rgbParts[0]);
                                const g = parseInt(rgbParts[1]);
                                const b = parseInt(rgbParts[2]);

                                const oklab = sRGB_to_OKLAB(r, g, b);

                                // Update Arrays
                                const idx3 = count * 3;

                                // Oklab
                                instanceOklabPos[idx3] = oklab.a;
                                instanceOklabPos[idx3 + 1] = oklab.L;
                                instanceOklabPos[idx3 + 2] = oklab.b;

                                // sRGB (Centered and Scaled)
                                instanceSrgbPos[idx3] = (r / 255 - 0.5) * 0.8;
                                instanceSrgbPos[idx3 + 1] = g / 255;
                                instanceSrgbPos[idx3 + 2] = (b / 255 - 0.5) * 0.8;

                                // Color
                                const col = new THREE.Color(hexStr);
                                instanceColor[idx3] = col.r;
                                instanceColor[idx3 + 1] = col.g;
                                instanceColor[idx3 + 2] = col.b;

                                instancedMesh.setMatrixAt(count, matrix);

                                count++;
                            }
                        }
                    }
                }

                instancedMesh.count = count;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.geometry.attributes.instanceOklabPos.needsUpdate = true;
                instancedMesh.geometry.attributes.instanceSrgbPos.needsUpdate = true;
                instancedMesh.geometry.attributes.instanceColor.needsUpdate = true;

                statusEl.textContent = `Loaded ${count} colors (N=${n}).`;
                requestRender();

            } catch (err) {
                console.error(err);
                statusEl.textContent = `Error: ${err.message}`;
                instancedMesh.count = 0;
                requestRender();
            }
        }

        // UI Handlers
        const nInput = document.getElementById('colorCount');
        const toggleBtn = document.getElementById('toggleMode');

        nInput.addEventListener('input', () => {
            const n = parseInt(nInput.value);
            if (n >= 3 && n <= 64) {
                loadData(n);
                const url = new URL(window.location);
                url.searchParams.set('n', n);
                window.history.pushState({}, '', url);
            }
        });

        toggleBtn.addEventListener('click', () => {
            targetMode = targetMode === 0 ? 1 : 0;
            toggleBtn.textContent = targetMode === 0 ? "Switch to sRGB" : "Switch to Oklab";

            const url = new URL(window.location);
            url.searchParams.set('mode', targetMode === 0 ? 'oklab' : 'srgb');
            window.history.pushState({}, '', url);

            requestRender();
        });

        const urlParams = new URLSearchParams(window.location.search);
        const initialN = urlParams.get('n') || 16;
        nInput.value = initialN;
        loadData(initialN);

        // Initial mode from URL
        const initialMode = urlParams.get('mode');
        if (initialMode === 'srgb' || initialMode === '1') {
            targetMode = 1;
            currentT = 1; // Start immediately in sRGB
            animationProgress = 1;
            uniforms.uT.value = 1;
            toggleBtn.textContent = "Switch to Oklab";
        }

        // --- Animation Loop ---

        // Septic polynomial: 35t^4 - 84t^5 + 70t^6 - 20t^7
        function septic(t) {
            return t * t * t * t * (35 + t * (-84 + t * (70 - 20 * t)));
        }

        function render() {
            renderRequested = false;
            controls.update();

            let needsMoreFrames = false;

            if (Math.abs(animationProgress - targetMode) > 0.0001) {
                // Move progress linearly towards target
                const speed = 0.02; // Adjust for duration
                if (animationProgress < targetMode) {
                    animationProgress = Math.min(targetMode, animationProgress + speed);
                } else {
                    animationProgress = Math.max(targetMode, animationProgress - speed);
                }

                // Apply septic easing
                currentT = septic(animationProgress);
                uniforms.uT.value = currentT;

                needsMoreFrames = true;
            }

            renderer.render(scene, camera);

            if (needsMoreFrames) {
                requestRender();
            }
        }

        // Initial render
        requestRender();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            requestRender();
        });
    </script>
</body>

</html>