<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Color Visualizer (OKLAB)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            pointer-events: auto;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            cursor: pointer;
            margin-top: 5px;
        }

        button:hover {
            background: #555;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h2>OKLAB Color Space Visualizer</h2>
        <div style="margin-bottom: 10px;">
            <label for="colorCount">Colors (N): </label>
            <input type="number" id="colorCount" min="3" max="64" value="16"
                style="width: 50px; background: #333; color: white; border: 1px solid #555;">
        </div>
        <button id="toggleMode">Switch to sRGB</button>
        <p id="status">Loading data...</p>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- OKLAB Math ---
        // Converted from https://bottosson.github.io/posts/oklab/

        function sRGB_to_linear(c) {
            return (c <= 0.04045) ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        }

        function linear_sRGB_to_OKLAB(r, g, b) {
            let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
            let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
            let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

            let l_ = Math.cbrt(l);
            let m_ = Math.cbrt(m);
            let s_ = Math.cbrt(s);

            return {
                L: 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
                a: 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
                b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
            };
        }

        function sRGB_to_OKLAB(r, g, b) {
            return linear_sRGB_to_OKLAB(sRGB_to_linear(r / 255), sRGB_to_linear(g / 255), sRGB_to_linear(b / 255));
        }

        function linear_sRGB_to_sRGB(c) {
            return (c <= 0.0031308) ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        }

        function OKLAB_to_linear_sRGB(L, a, b) {
            let l_ = L + 0.3963377774 * a + 0.2158037573 * b;
            let m_ = L - 0.1055613458 * a - 0.0638541728 * b;
            let s_ = L - 0.0894841775 * a - 1.2914855480 * b;

            let l = l_ * l_ * l_;
            let m = m_ * m_ * m_;
            let s = s_ * s_ * s_;

            return {
                r: +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
                g: -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
                b: -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
            };
        }

        function OKLAB_to_sRGB(L, a, b) {
            let lin = OKLAB_to_linear_sRGB(L, a, b);
            return {
                r: linear_sRGB_to_sRGB(lin.r),
                g: linear_sRGB_to_sRGB(lin.g),
                b: linear_sRGB_to_sRGB(lin.b)
            };
        }

        // --- Shaders ---
        const vertexShaderCommon = `
            uniform float uT;
            attribute vec3 oklabPos;
            attribute vec3 srgbPos;
            attribute vec3 color;
            varying vec3 vColor;
            
            void main() {
                vColor = color;
                vec3 pos = mix(oklabPos, srgbPos, uT);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShaderCommon = `
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // For Lines, we might want opacity
        const fragmentShaderLines = `
            varying vec3 vColor;
            uniform float opacity;
            void main() {
                gl_FragColor = vec4(vColor, opacity);
            }
        `;

        // For Instanced Spheres
        // We use a slightly different vertex shader because we need to add the sphere's local position
        const vertexShaderInstanced = `
            uniform float uT;
            attribute vec3 instanceOklabPos;
            attribute vec3 instanceSrgbPos;
            attribute vec3 instanceColor;
            varying vec3 vColor;

            void main() {
                vColor = instanceColor;
                vec3 offset = mix(instanceOklabPos, instanceSrgbPos, uT);
                vec3 transformed = position + offset;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
        `;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        camera.position.set(0.8, 0.8, 0.8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0.5, 0);

        // Idle Render Logic
        let renderRequested = false;
        function requestRender() {
            if (!renderRequested) {
                renderRequested = true;
                requestAnimationFrame(render);
            }
        }

        controls.addEventListener('change', requestRender);

        // --- Animation State ---
        let targetMode = 0; // 0 = Oklab, 1 = sRGB
        let currentT = 0;
        let animationProgress = 0;

        // Uniforms shared by materials
        const uniforms = {
            uT: { value: 0 }
        };

        // --- Geometry Creation ---

        // Custom Axes
        function createAxes() {
            const axesGroup = new THREE.Group();
            const steps = 64;

            function addGradientAxis(start, end) {
                const positions = []; // Dummy positions, shader uses attributes
                const oklabPos = [];
                const srgbPos = [];
                const colors = [];

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = start.x + (end.x - start.x) * t;
                    const y = start.y + (end.y - start.y) * t;
                    const z = start.z + (end.z - start.z) * t;

                    positions.push(0, 0, 0); // Not used but required for bounding box calc usually

                    // Oklab Position
                    oklabPos.push(x, y, z);

                    // sRGB Position (mapped from Oklab)
                    const rgb = OKLAB_to_sRGB(y, x, z); // L=y, a=x, b=z
                    const r = Math.max(0, Math.min(1, rgb.r));
                    const g = Math.max(0, Math.min(1, rgb.g));
                    const bl = Math.max(0, Math.min(1, rgb.b));

                    // Center sRGB: subtract 0.5 from x and z, then scale by 0.8 to match axes
                    srgbPos.push((r - 0.5) * 0.8, g, (bl - 0.5) * 0.8);

                    colors.push(r, g, bl);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('oklabPos', new THREE.Float32BufferAttribute(oklabPos, 3));
                geometry.setAttribute('srgbPos', new THREE.Float32BufferAttribute(srgbPos, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: vertexShaderCommon,
                    fragmentShader: fragmentShaderCommon,
                    transparent: false,
                    linewidth: 2
                });

                axesGroup.add(new THREE.Line(geometry, material));
            }

            // L axis (Vertical)
            addGradientAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
            // a axis (Horizontal)
            addGradientAxis(new THREE.Vector3(-0.4, 0.5, 0), new THREE.Vector3(0.4, 0.5, 0));
            // b axis (Depth)
            addGradientAxis(new THREE.Vector3(0, 0.5, -0.4), new THREE.Vector3(0, 0.5, 0.4));

            scene.add(axesGroup);
        }
        createAxes();

        // --- Gamut Visualization ---
        function createGamutWireframe() {
            const gridPointsOklab = [];
            const gridPointsRGB = [];
            const gridColors = []; // We need colors for the shader
            const steps = 20;
            const gridDivisions = 10;
            const dummyPos = [];

            function addGridSegment(p1, p2) {
                for (let i = 0; i < steps; i++) {
                    let t1 = i / steps;
                    let t2 = (i + 1) / steps;

                    // Interpolate in sRGB space (linear)
                    let c1 = [p1[0] + (p2[0] - p1[0]) * t1, p1[1] + (p2[1] - p1[1]) * t1, p1[2] + (p2[2] - p1[2]) * t1];
                    let c2 = [p1[0] + (p2[0] - p1[0]) * t2, p1[1] + (p2[1] - p1[1]) * t2, p1[2] + (p2[2] - p1[2]) * t2];

                    // sRGB positions (Centered and Scaled)
                    gridPointsRGB.push((c1[0] - 0.5) * 0.8, c1[1], (c1[2] - 0.5) * 0.8);
                    gridPointsRGB.push((c2[0] - 0.5) * 0.8, c2[1], (c2[2] - 0.5) * 0.8);

                    // Oklab positions
                    let o1 = sRGB_to_OKLAB(c1[0] * 255, c1[1] * 255, c1[2] * 255);
                    let o2 = sRGB_to_OKLAB(c2[0] * 255, c2[1] * 255, c2[2] * 255);
                    gridPointsOklab.push(o1.a, o1.L, o1.b);
                    gridPointsOklab.push(o2.a, o2.L, o2.b);

                    // Constant color for grid
                    gridColors.push(0.33, 0.33, 0.33);
                    gridColors.push(0.33, 0.33, 0.33);

                    dummyPos.push(0, 0, 0, 0, 0, 0);
                }
            }

            function drawFaceGrid(fixedDim, fixedVal) {
                for (let i = 1; i < gridDivisions; i++) {
                    let t = i / gridDivisions;
                    let start1 = [0, 0, 0]; start1[fixedDim] = fixedVal;
                    let end1 = [0, 0, 0]; end1[fixedDim] = fixedVal;
                    let start2 = [0, 0, 0]; start2[fixedDim] = fixedVal;
                    let end2 = [0, 0, 0]; end2[fixedDim] = fixedVal;
                    let d1 = (fixedDim + 1) % 3;
                    let d2 = (fixedDim + 2) % 3;
                    start1[d1] = 0; start1[d2] = t; end1[d1] = 1; end1[d2] = t;
                    addGridSegment(start1, end1);
                    start2[d2] = 0; start2[d1] = t; end2[d2] = 1; end2[d1] = t;
                    addGridSegment(start2, end2);
                }
            }

            drawFaceGrid(0, 0); drawFaceGrid(0, 1);
            drawFaceGrid(1, 0); drawFaceGrid(1, 1);
            drawFaceGrid(2, 0); drawFaceGrid(2, 1);

            const gridGeo = new THREE.BufferGeometry();
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(dummyPos, 3));
            gridGeo.setAttribute('oklabPos', new THREE.Float32BufferAttribute(gridPointsOklab, 3));
            gridGeo.setAttribute('srgbPos', new THREE.Float32BufferAttribute(gridPointsRGB, 3));
            gridGeo.setAttribute('color', new THREE.Float32BufferAttribute(gridColors, 3));

            const gridMat = new THREE.ShaderMaterial({
                uniforms: { ...uniforms, opacity: { value: 0.1 } },
                vertexShader: vertexShaderCommon,
                fragmentShader: fragmentShaderLines,
                transparent: true,
                depthWrite: false
            });
            const gridLines = new THREE.LineSegments(gridGeo, gridMat);
            scene.add(gridLines);

            // Main Edges
            const edgePositionsOklab = [];
            const edgePositionsRGB = [];
            const edgeColors = [];
            const edgeDummyPos = [];

            function addColoredEdge(p1, p2) {
                for (let i = 0; i < steps; i++) {
                    let t1 = i / steps;
                    let t2 = (i + 1) / steps;

                    let c1 = [p1[0] + (p2[0] - p1[0]) * t1, p1[1] + (p2[1] - p1[1]) * t1, p1[2] + (p2[2] - p1[2]) * t1];
                    let c2 = [p1[0] + (p2[0] - p1[0]) * t2, p1[1] + (p2[1] - p1[1]) * t2, p1[2] + (p2[2] - p1[2]) * t2];

                    // Centered sRGB and Scaled
                    edgePositionsRGB.push((c1[0] - 0.5) * 0.8, c1[1], (c1[2] - 0.5) * 0.8);
                    edgePositionsRGB.push((c2[0] - 0.5) * 0.8, c2[1], (c2[2] - 0.5) * 0.8);

                    let o1 = sRGB_to_OKLAB(c1[0] * 255, c1[1] * 255, c1[2] * 255);
                    let o2 = sRGB_to_OKLAB(c2[0] * 255, c2[1] * 255, c2[2] * 255);

                    edgePositionsOklab.push(o1.a, o1.L, o1.b);
                    edgePositionsOklab.push(o2.a, o2.L, o2.b);

                    edgeColors.push(c1[0], c1[1], c1[2]);
                    edgeColors.push(c2[0], c2[1], c2[2]);

                    edgeDummyPos.push(0, 0, 0, 0, 0, 0);
                }
            }

            addColoredEdge([0, 0, 0], [1, 0, 0]); addColoredEdge([1, 0, 0], [1, 1, 0]); addColoredEdge([1, 1, 0], [0, 1, 0]); addColoredEdge([0, 1, 0], [0, 0, 0]);
            addColoredEdge([0, 0, 1], [1, 0, 1]); addColoredEdge([1, 0, 1], [1, 1, 1]); addColoredEdge([1, 1, 1], [0, 1, 1]); addColoredEdge([0, 1, 1], [0, 0, 1]);
            addColoredEdge([0, 0, 0], [0, 0, 1]); addColoredEdge([1, 0, 0], [1, 0, 1]); addColoredEdge([1, 1, 0], [1, 1, 1]); addColoredEdge([0, 1, 0], [0, 1, 1]);

            const edgeGeo = new THREE.BufferGeometry();
            edgeGeo.setAttribute('position', new THREE.Float32BufferAttribute(edgeDummyPos, 3));
            edgeGeo.setAttribute('oklabPos', new THREE.Float32BufferAttribute(edgePositionsOklab, 3));
            edgeGeo.setAttribute('srgbPos', new THREE.Float32BufferAttribute(edgePositionsRGB, 3));
            edgeGeo.setAttribute('color', new THREE.Float32BufferAttribute(edgeColors, 3));

            const edgeMat = new THREE.ShaderMaterial({
                uniforms: { ...uniforms, opacity: { value: 0.8 } },
                vertexShader: vertexShaderCommon,
                fragmentShader: fragmentShaderLines,
                transparent: true,
                linewidth: 2
            });
            const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
            scene.add(edgeLines);
        }

        createGamutWireframe();

        // --- Data Loading ---
        let currentInstancedMesh = null;

        async function loadData(n) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `Loading results/colors_${n}.txt...`;

            try {
                const response = await fetch(`results/colors_${n}.txt`);
                if (!response.ok) throw new Error(`File not found: ${response.statusText}`);

                const text = await response.text();
                const lines = text.split('\n');

                const dataPoints = [];

                lines.forEach(line => {
                    line = line.trim();
                    if (/^\d+/.test(line)) {
                        const parts = line.split(/\s+/);
                        if (parts.length >= 6) {
                            const hex = parts[1];
                            const rgbStr = parts[2];
                            const rgb = rgbStr.split(',').map(Number);
                            const oklab = sRGB_to_OKLAB(rgb[0], rgb[1], rgb[2]);

                            dataPoints.push({
                                rgb: rgb,
                                oklab: oklab,
                                hex: hex
                            });
                        }
                    }
                });

                // Remove old mesh
                if (currentInstancedMesh) {
                    scene.remove(currentInstancedMesh);
                    currentInstancedMesh.geometry.dispose();
                    currentInstancedMesh.material.dispose();
                    currentInstancedMesh = null;
                }

                if (dataPoints.length > 0) {
                    const geometry = new THREE.SphereGeometry(0.02, 16, 16); // Reduced segments for performance
                    const material = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: vertexShaderInstanced,
                        fragmentShader: fragmentShaderCommon
                    });

                    const instancedMesh = new THREE.InstancedMesh(geometry, material, dataPoints.length);

                    const instanceOklabPos = new Float32Array(dataPoints.length * 3);
                    const instanceSrgbPos = new Float32Array(dataPoints.length * 3);
                    const instanceColor = new Float32Array(dataPoints.length * 3);

                    const dummy = new THREE.Object3D();

                    dataPoints.forEach((pt, i) => {
                        // Oklab
                        instanceOklabPos[i * 3] = pt.oklab.a;
                        instanceOklabPos[i * 3 + 1] = pt.oklab.L;
                        instanceOklabPos[i * 3 + 2] = pt.oklab.b;

                        // sRGB (Centered and Scaled)
                        instanceSrgbPos[i * 3] = (pt.rgb[0] / 255 - 0.5) * 0.8;
                        instanceSrgbPos[i * 3 + 1] = pt.rgb[1] / 255;
                        instanceSrgbPos[i * 3 + 2] = (pt.rgb[2] / 255 - 0.5) * 0.8;

                        // Color
                        const col = new THREE.Color(pt.hex);
                        instanceColor[i * 3] = col.r;
                        instanceColor[i * 3 + 1] = col.g;
                        instanceColor[i * 3 + 2] = col.b;

                        // Set identity matrix (we do positioning in shader)
                        dummy.position.set(0, 0, 0);
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(i, dummy.matrix);
                    });

                    geometry.setAttribute('instanceOklabPos', new THREE.InstancedBufferAttribute(instanceOklabPos, 3));
                    geometry.setAttribute('instanceSrgbPos', new THREE.InstancedBufferAttribute(instanceSrgbPos, 3));
                    geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColor, 3));

                    scene.add(instancedMesh);
                    currentInstancedMesh = instancedMesh;
                }

                statusEl.textContent = `Loaded ${dataPoints.length} colors (N=${n}).`;
                requestRender();

            } catch (err) {
                console.error(err);
                statusEl.textContent = `Error: ${err.message}`;
                if (currentInstancedMesh) {
                    scene.remove(currentInstancedMesh);
                    currentInstancedMesh = null;
                }
                requestRender();
            }
        }

        // UI Handlers
        const nInput = document.getElementById('colorCount');
        const toggleBtn = document.getElementById('toggleMode');

        nInput.addEventListener('input', () => {
            const n = parseInt(nInput.value);
            if (n >= 3 && n <= 64) {
                loadData(n);
                const url = new URL(window.location);
                url.searchParams.set('n', n);
                window.history.pushState({}, '', url);
            }
        });

        toggleBtn.addEventListener('click', () => {
            targetMode = targetMode === 0 ? 1 : 0;
            toggleBtn.textContent = targetMode === 0 ? "Switch to sRGB" : "Switch to Oklab";

            const url = new URL(window.location);
            url.searchParams.set('mode', targetMode === 0 ? 'oklab' : 'srgb');
            window.history.pushState({}, '', url);

            requestRender();
        });

        const urlParams = new URLSearchParams(window.location.search);
        const initialN = urlParams.get('n') || 16;
        nInput.value = initialN;
        loadData(initialN);

        // Initial mode from URL
        const initialMode = urlParams.get('mode');
        if (initialMode === 'srgb' || initialMode === '1') {
            targetMode = 1;
            currentT = 1; // Start immediately in sRGB
            animationProgress = 1;
            uniforms.uT.value = 1;
            toggleBtn.textContent = "Switch to Oklab";
        }

        // --- Animation Loop ---

        // Septic polynomial: 35t^4 - 84t^5 + 70t^6 - 20t^7
        function septic(t) {
            return t * t * t * t * (35 + t * (-84 + t * (70 - 20 * t)));
        }

        function render() {
            renderRequested = false;
            controls.update();

            let needsMoreFrames = false;

            if (Math.abs(animationProgress - targetMode) > 0.0001) {
                // Move progress linearly towards target
                const speed = 0.02; // Adjust for duration
                if (animationProgress < targetMode) {
                    animationProgress = Math.min(targetMode, animationProgress + speed);
                } else {
                    animationProgress = Math.max(targetMode, animationProgress - speed);
                }

                // Apply septic easing
                currentT = septic(animationProgress);
                uniforms.uT.value = currentT;

                needsMoreFrames = true;
            }

            renderer.render(scene, camera);

            if (needsMoreFrames) {
                requestRender();
            }
        }

        // Initial render
        requestRender();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            requestRender();
        });
    </script>
</body>

</html>